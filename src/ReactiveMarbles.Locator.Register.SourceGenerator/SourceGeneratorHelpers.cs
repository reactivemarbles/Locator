// Copyright (c) 2019-2021 ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ReactiveMarbles.Locator.Register.SourceGenerator.Metadata;
using static ReactiveMarbles.RoslynHelpers.SyntaxFactoryHelpers;

namespace ReactiveMarbles.Locator.Register.SourceGenerator;

internal static class SourceGeneratorHelpers
{
    private const string RegisterMethodName = "AddService";
    private const string RegisterLazySingletonMethodName = "AddLazySingleton";

    public static string Generate(in GeneratorExecutionContext context, Compilation compilation, SyntaxReceiver syntaxReceiver)
    {
        var methods = MetadataExtractor.GetValidMethods(context, syntaxReceiver, compilation).ToList();

        methods = MetadataDependencyChecker.CheckMetadata(context, methods);

        var invocations = Generate(methods);

        var constructIoc = MethodDeclaration(
            new[] { SyntaxKind.StaticKeyword, SyntaxKind.PartialKeyword },
            "void",
            Constants.IocMethod,
            new[] { Parameter(Constants.ResolverType, Constants.ResolverParameterName) },
            1,
            Block(invocations.ToList(), 2));

        var registrationClass = ClassDeclaration(Constants.ClassName, new[] { SyntaxKind.InternalKeyword, SyntaxKind.StaticKeyword, SyntaxKind.PartialKeyword }, new[] { constructIoc }, 1);

        var namespaceDeclaration = NamespaceDeclaration(Constants.NamespaceName, new[] { registrationClass }, false);

        var compilationUnit = CompilationUnit(default, new[] { namespaceDeclaration }, Array.Empty<UsingDirectiveSyntax>());

        return $@"
// <auto-generated />
{compilationUnit.ToFullString()}";
    }

    private static IEnumerable<StatementSyntax> Generate(IEnumerable<MethodMetadata> methodMetadataEnumerable)
    {
        foreach (var methodMetadata in methodMetadataEnumerable)
        {
            var typeConstructorArguments = methodMetadata.ConstructorDependencies
                .Select(parameter => Get(parameter.Type))
                .Select(Argument)
                .ToList();

            var contractParameter = methodMetadata.RegisterParameterValues.FirstOrDefault(x => x.ParameterName == "contract");

            string? contract = null;
            if (contractParameter is not null)
            {
                contract = contractParameter.ParameterValue;
            }

            var initializer = GetPropertyInitializer(methodMetadata.Properties);

            ExpressionSyntax call = initializer is null ?
                ObjectCreationExpression(methodMetadata.ConcreteTypeName, typeConstructorArguments) :
                ObjectCreationExpression(methodMetadata.ConcreteTypeName, typeConstructorArguments, initializer);

            switch (methodMetadata)
            {
                case RegisterLazySingletonMetadata lazyMetadata:
                    yield return GenerateLocatorLazySetService(Argument(ParenthesizedLambdaExpression(call)), lazyMetadata.InterfaceTypeName, contract);
                    break;
                case RegisterMetadata registerMetadata:
                    yield return GenerateLocatorSetService(Argument(ParenthesizedLambdaExpression(call)), registerMetadata.InterfaceTypeName, contract);
                    break;
            }
        }
    }

    private static InitializerExpressionSyntax? GetPropertyInitializer(IEnumerable<PropertyDependencyMetadata> properties)
    {
        var propertySet = properties
            .Select(property =>
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    property.Name,
                    GetService(property.TypeName)))
            .ToList();

        return propertySet.Count > 0 ? InitializerExpression(SyntaxKind.ObjectInitializerExpression, propertySet) : null;
    }

    private static ExpressionSyntax Get(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType && namedTypeSymbol.TypeArguments.Length == 1 && namedTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Lazy"))
        {
            return GetLazyService(namedTypeSymbol.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
        }

        return GetService(typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
    }

    private static ExpressionSyntax GetService(string parameterTypeName) =>
        InvocationExpression(
            MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                Constants.ResolverParameterName,
                GenericName(Constants.LocatorGetService, new TypeSyntax[] { IdentifierName(parameterTypeName) })));

    private static ExpressionSyntax GetLazyService(string parameterTypeName) =>
        InvocationExpression(
            MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                Constants.ResolverParameterName,
                GenericName(Constants.LocatorGetLazyService, new TypeSyntax[] { IdentifierName(parameterTypeName) })));

    private static ExpressionStatementSyntax GenerateLocatorSetService(ArgumentSyntax argument, string interfaceType, string? contract)
    {
        var lambdaArguments = new List<ArgumentSyntax>
        {
            argument,
        };

        if (contract is not null)
        {
            lambdaArguments.Add(Argument(contract));
        }

        return ExpressionStatement(InvocationExpression(
            MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                Constants.ResolverParameterName,
                GenericName(RegisterMethodName, new TypeSyntax[] { IdentifierName(interfaceType) })),
            lambdaArguments));
    }

    private static ExpressionStatementSyntax GenerateLocatorLazySetService(ArgumentSyntax argument, string interfaceType, string? contract)
    {
        var lambdaArguments = new List<ArgumentSyntax>
        {
            argument,
        };

        if (contract is not null)
        {
            lambdaArguments.Add(Argument(contract));
        }

        return ExpressionStatement(InvocationExpression(
            MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                Constants.ResolverParameterName,
                GenericName(RegisterLazySingletonMethodName, new TypeSyntax[] { IdentifierName(interfaceType) })),
            lambdaArguments));
    }
}
